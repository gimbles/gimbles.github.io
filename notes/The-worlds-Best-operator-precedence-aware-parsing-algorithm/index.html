<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="We here at Gimbling Science take cursedness very seriously. I’m Gim! I own the place. This is my first article on this (unchanged until now) website as part of The Writing Gaggle in the Rust Community Discord Server."><meta property="og:title" content="The world's Best* operator precedence-aware parsing algorithm"><meta property="og:description" content="We here at Gimbling Science take cursedness very seriously. I’m Gim! I own the place. This is my first article on this (unchanged until now) website as part of The Writing Gaggle in the Rust Community Discord Server."><meta property="og:type" content="website"><meta property="og:image" content="https://gimbles.github.io/icon.png"><meta property="og:url" content="https://gimbles.github.io/notes/The-worlds-Best-operator-precedence-aware-parsing-algorithm/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="The world's Best* operator precedence-aware parsing algorithm"><meta name=twitter:description content="We here at Gimbling Science take cursedness very seriously. I’m Gim! I own the place. This is my first article on this (unchanged until now) website as part of The Writing Gaggle in the Rust Community Discord Server."><meta name=twitter:image content="https://gimbles.github.io/icon.png"><title>The world's Best* operator precedence-aware parsing algorithm</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://gimbles.github.io//icon.png><link href=https://gimbles.github.io/styles.0581c1cfba86cef9be41e096e0c65716.min.css rel=stylesheet><link href=https://gimbles.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://gimbles.github.io/js/darkmode.f25b015fcb5dba21e77875f8a5e9f202.min.js></script>
<script src=https://gimbles.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://gimbles.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://gimbles.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://gimbles.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://gimbles.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://gimbles.github.io/",fetchData=Promise.all([fetch("https://gimbles.github.io/indices/linkIndex.623416562cc6bb5a11da77a5afae7765.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://gimbles.github.io/indices/contentIndex.c19f5dd21af9c49b4725ef9f8d56f920.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://gimbles.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://gimbles.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/gimbles.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=gimbles.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://gimbles.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://gimbles.github.io/>Gimbles</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>The world's Best* operator precedence-aware parsing algorithm</h1><p class=meta>Last updated
Apr 15, 2023
<a href=https://github.com/gimbles/gimbles.github.io/tree/hugo/content/notes/The%20world%27s%20Best*%20operator%20precedence-aware%20parsing%20algorithm.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents></nav></details></aside><p>We here at Gimbling Science take cursedness very seriously. I’m Gim! I own the place. This is my first article on this (unchanged until now) website as part of The Writing Gaggle in the Rust Community Discord Server. I’m generally pretty excited.</p><blockquote><p>Cat: And so am I!</p></blockquote><p>That eager voice you heard is the lovely Cat, my assistant. Rest assured, she won’t interrupt you too much. Isn’t that <em>right</em>, Cat?</p><blockquote><p>Cat: I’ll try (meow)</p></blockquote><p>She’s the backbone of this corporation. Cute as a cat (duh), too. Sorry, fellas. She’s married. To cursed!</p><a href=#right-where-were-we><h1 id=right-where-were-we><span class=hanchor arialabel=Anchor># </span>Right, where were we?</h1></a><p>Let’s hold our meows together, folks, and get our weapons together. My weapon of choice is
<a href=https://fsharp.org/ rel=noopener>F#</a>.</p><p>For the sake of simplicity, this article will only focus on basic <em>math</em>. Emphasis on <em>basic</em>.</p><blockquote><p>Cat: Did you just~</p></blockquote><p>Shhh.</p><a href=#whats-the-fuzz-gim><h1 id=whats-the-fuzz-gim><span class=hanchor arialabel=Anchor># </span>What’s the fuzz, Gim?</h1></a><p>Now we all know the good ol’ Pratt Parsing. Some people even prefer recursive descent. But nothing is as cursed as <em>The FORTRAN way.</em></p><p>Let’s dive into
<a href=https://en.wikipedia.org/wiki/Operator-precedence_parser rel=noopener>Wikipedia…</a></p><blockquote><p>Another approach is to first fully parenthesize the expression, inserting a number of parentheses around each operator, such that they lead to the correct precedence even when parsed with a linear, left-to-right parser. This algorithm was used in the early
<a href=https://web.archive.org/web/20230517120658/https://en.wikipedia.org/wiki/Fortran#FORTRAN rel=noopener>FORTRAN I</a> compiler:
<a href=https://en.wikipedia.org/wiki/Operator-precedence_parser#cite_note-Padua2000-7 rel=noopener>[7]</a></p></blockquote><blockquote><p>The Fortran I compiler would expand each operator with a sequence of parentheses. In a simplified form of the algorithm, it would</p><ul><li>replace <code>+</code> and <code>–</code> with <code>))+((</code> and <code>))-((</code>, respectively;</li><li>replace <code>*</code> and <code>/</code> with <code>)*(</code> and <code>)/(</code>, respectively;</li><li>add <code>((</code> at the beginning of each expression and after each left parenthesis in the original expression; and</li><li>add <code>))</code> at the end of the expression and before each right parenthesis in the original expression.</li></ul><p>Although not obvious, the algorithm was correct, and, in the words of
<a href=https://web.archive.org/web/20230517120658/https://en.wikipedia.org/wiki/Donald_Knuth rel=noopener>Knuth</a>, “The resulting formula is properly parenthesized, believe it or not.”
<a href=https://web.archive.org/web/20230517120658/https://en.wikipedia.org/wiki/Operator-precedence_parser#cite_note-Knuth1962-8 rel=noopener>[8]</a></p></blockquote><p>Look, I said cursed <em>for a reason.</em> And in the words of Knuth, it <em>works</em>. So don’t touch it.</p><blockquote><p>Cat: I don’t think Knuth said that, Gim…</p></blockquote><a href=#the-lexer><h1 id=the-lexer><span class=hanchor arialabel=Anchor># </span>The Lexer</h1></a><p>That means all we have is parenthesis for scoping, integers for integers, and operators for operating.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=nv>rec</span> <span class=k>private</span> <span class=n>lex_</span> <span class=o>(</span><span class=n>source</span><span class=o>:</span> <span class=kt>char</span> <span class=n>ReadOnlySpan</span><span class=o>)</span> <span class=o>(</span><span class=n>index</span><span class=o>:</span> <span class=n>int</span><span class=o>)</span> <span class=o>(</span><span class=n>collector</span><span class=o>:</span> <span class=n>Token</span> <span class=n>array</span><span class=o>)</span> <span class=o>=</span>  
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>index</span> <span class=o>=</span> <span class=n>source</span><span class=o>.</span><span class=n>Length</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>		<span class=n>collector</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span>
</span></span><span class=line><span class=cl>		<span class=k>let</span> <span class=nv>character</span> <span class=o>=</span> <span class=n>source</span><span class=o>[</span><span class=n>index</span><span class=o>]</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>		<span class=k>match</span> <span class=n>character</span> <span class=k>with</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=sc>&#39; &#39;</span> <span class=o>-&gt;</span> <span class=n>lex_</span> <span class=n>source</span> <span class=o>(</span><span class=n>index</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=n>collector</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=sc>&#39;+&#39;</span> <span class=o>-&gt;</span> <span class=n>lex_</span> <span class=n>source</span> <span class=o>(</span><span class=n>index</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>(</span><span class=nn>Array</span><span class=p>.</span><span class=n>append</span> <span class=n>collector</span> <span class=o>[|</span> <span class=n>RParen</span><span class=o>;</span> <span class=n>RParen</span><span class=o>;</span> <span class=n>Add</span><span class=o>;</span> <span class=n>LParen</span><span class=o>;</span> <span class=n>LParen</span> <span class=o>|])</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=sc>&#39;-&#39;</span> <span class=o>-&gt;</span> <span class=n>lex_</span> <span class=n>source</span> <span class=o>(</span><span class=n>index</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>(</span><span class=nn>Array</span><span class=p>.</span><span class=n>append</span> <span class=n>collector</span> <span class=o>[|</span> <span class=n>RParen</span><span class=o>;</span> <span class=n>RParen</span><span class=o>;</span> <span class=n>Sub</span><span class=o>;</span> <span class=n>LParen</span><span class=o>;</span> <span class=n>LParen</span> <span class=o>|])</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=sc>&#39;/&#39;</span> <span class=o>-&gt;</span> <span class=n>lex_</span> <span class=n>source</span> <span class=o>(</span><span class=n>index</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>(</span><span class=nn>Array</span><span class=p>.</span><span class=n>append</span> <span class=n>collector</span> <span class=o>[|</span> <span class=n>RParen</span><span class=o>;</span> <span class=n>Div</span><span class=o>;</span> <span class=n>LParen</span> <span class=o>|])</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=sc>&#39;*&#39;</span> <span class=o>-&gt;</span> <span class=n>lex_</span> <span class=n>source</span> <span class=o>(</span><span class=n>index</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>(</span><span class=nn>Array</span><span class=p>.</span><span class=n>append</span> <span class=n>collector</span> <span class=o>[|</span> <span class=n>RParen</span><span class=o>;</span> <span class=n>Mul</span><span class=o>;</span> <span class=n>LParen</span> <span class=o>|])</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=sc>&#39;(&#39;</span> <span class=o>-&gt;</span> <span class=n>lex_</span> <span class=n>source</span> <span class=o>(</span><span class=n>index</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>(</span><span class=nn>Array</span><span class=p>.</span><span class=n>append</span> <span class=n>collector</span> <span class=o>[|</span> <span class=n>LParen</span><span class=o>;</span> <span class=n>LParen</span><span class=o>;</span> <span class=n>LParen</span> <span class=o>|])</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=sc>&#39;)&#39;</span> <span class=o>-&gt;</span> <span class=n>lex_</span> <span class=n>source</span> <span class=o>(</span><span class=n>index</span> <span class=o>+</span> <span class=n>1</span><span class=o>)</span> <span class=o>(</span><span class=nn>Array</span><span class=p>.</span><span class=n>append</span> <span class=n>collector</span> <span class=o>[|</span> <span class=n>RParen</span><span class=o>;</span> <span class=n>RParen</span><span class=o>;</span> <span class=n>RParen</span> <span class=o>|])</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=kt>char</span> <span class=k>when</span> <span class=nn>Char</span><span class=p>.</span><span class=n>IsDigit</span> <span class=kt>char</span> <span class=o>-&gt;</span>  
</span></span><span class=line><span class=cl>			<span class=k>let</span> <span class=nv>index_till_int</span> <span class=o>=</span> <span class=o>(</span><span class=n>consumeWhile</span> <span class=n>source</span> <span class=o>(</span><span class=nn>Char</span><span class=p>.</span><span class=n>IsDigit</span> <span class=o>&gt;&gt;</span> <span class=ow>not</span><span class=o>)</span> <span class=n>index</span><span class=o>)</span>  
</span></span><span class=line><span class=cl>			<span class=k>let</span> <span class=nv>int</span> <span class=o>=</span> <span class=kt>double</span> <span class=o>(</span><span class=n>source</span><span class=o>.</span><span class=n>Slice</span><span class=o>(</span><span class=n>index</span><span class=o>,</span> <span class=n>index_till_int</span> <span class=o>-</span> <span class=n>index</span><span class=o>).</span><span class=n>ToString</span><span class=bp>()</span><span class=o>)</span>  
</span></span><span class=line><span class=cl>			<span class=n>lex_</span> <span class=n>source</span> <span class=n>index_till_int</span> <span class=o>(</span><span class=nn>Array</span><span class=p>.</span><span class=n>append</span> <span class=n>collector</span> <span class=o>[|</span> <span class=n>Integer</span> <span class=n>int</span> <span class=o>|])</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=kt>char</span> <span class=o>-&gt;</span> <span class=n>failwith</span> <span class=o>$</span><span class=s>&#34;Unknown token {char}&#34;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=nv>lex</span> <span class=o>(</span><span class=n>source</span><span class=o>:</span> <span class=kt>char</span> <span class=n>ReadOnlySpan</span><span class=o>)</span> <span class=o>=</span> <span class=n>lex_</span> <span class=n>source</span> <span class=n>0</span> <span class=o>[||]</span>
</span></span></code></pre></td></tr></table></div></div><p>Let’s go step-by-step, understanding what’s going on here. Now I’m a <em>Span/ReadOnlySpan shill</em>. Functional programming doesn’t have to be slow! I blame the linked lists! The govermen~</p><blockquote><p>Cat: Sir, the lexer.</p></blockquote><p>Right. A brief overview of what’s going on here is this. Our main lexer is in a private function <code>lex_</code>. I’ll explain later why this needs to be a thing.</p><p>We take in a parameter, containing the original source code. Strings in .NET land are arrays of <em>chars.</em> They even have an implicit conversion operator to <code>ReadOnlySpan&lt;char></code>. The second being the <em>index</em> we’re currently at. And the third being a collector that we append our tokens into.</p><p>We get our current character by indexing the span with the current index, and we iterate by recursing with the index bumped up. This is <em>fast!</em> As fast as traditional looping. Although, this is talks for later.</p><p>If the current index is same as the length of the original source, we can conclude that we have reached the end of the source and we can stop lexing further. Now it’s pretty simple, our grammar isn’t really that complex. In a real compiler, I would use a lexer generator like
<a href=https://lib.rs/logos rel=noopener>Logos</a> instead however.</p><p>We match over the character, ignoring the whitespace entirely and just bumping the index. Then matching over the different operators and…</p><blockquote><p>Cat: WTF?!</p></blockquote><p>Cat, did you not read the script? Just scroll up a bit, you lazy bastard.</p><p>At the lexer stage, we transform the operators into what the algorithm defines.</p><blockquote><ul><li>replace <code>+</code> and <code>–</code> with <code>))+((</code> and <code>))-((</code>, respectively;</li><li>replace <code>*</code> and <code>/</code> with <code>)*(</code> and <code>)/(</code>, respectively;</li></ul></blockquote><p>Same with the parenthesis.</p><blockquote><ul><li>add <code>((</code> at the beginning of each expression and after <strong>each left parenthesis in the original expression</strong>; and</li><li>add <code>))</code> at the end of the expression and before <strong>each right parenthesis in the original expression</strong>.</li></ul></blockquote><p>To lex integers, we increment the current index till <code>source[index]</code> is a <em>digit</em>. Then we fetch a sub-span from the original span, convert it into a string, and parse it as a <strong><code>double</code></strong>.</p><blockquote><p>Cat: Sir, you remember that time you threatened people to blow them up with combustible floats?</p></blockquote><p>Cat, this is desparate times.</p><p>That’s our entire lexer! That’s all we have. Fear not, war hero, we will implement this same algorithm in the future in a <em>real</em> language with complex expressions and not just integers. We don’t even have unops yet.</p><a href=#the-parser><h1 id=the-parser><span class=hanchor arialabel=Anchor># </span>The Parser</h1></a><p>Our parser needs to parse into a some structure. Our grammar isn’t particularly complex enough to have a proper AST. However, we can represent an expression using a structure like this.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>RequireQualifiedAccess</span><span class=o>&gt;]</span>  
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>Expr</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>Add</span> <span class=k>of</span> <span class=n>Expr</span> <span class=o>*</span> <span class=n>Expr</span>  
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>Sub</span> <span class=k>of</span> <span class=n>Expr</span> <span class=o>*</span> <span class=n>Expr</span>  
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>Mul</span> <span class=k>of</span> <span class=n>Expr</span> <span class=o>*</span> <span class=n>Expr</span>  
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>Div</span> <span class=k>of</span> <span class=n>Expr</span> <span class=o>*</span> <span class=n>Expr</span>  
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>Paren</span> <span class=k>of</span> <span class=n>Expr</span>  
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>Integer</span> <span class=k>of</span> <span class=kt>double</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=k>override</span> <span class=n>self</span><span class=p>.</span><span class=nf>ToString</span><span class=bp>()</span> <span class=o>=</span>  
</span></span><span class=line><span class=cl>        <span class=k>match</span> <span class=n>self</span> <span class=k>with</span>  
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>Add</span><span class=o>(</span><span class=n>expr</span><span class=o>,</span> <span class=n>expr1</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>$</span><span class=s>&#34;{expr}+{expr1}&#34;</span>  
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>Sub</span><span class=o>(</span><span class=n>expr</span><span class=o>,</span> <span class=n>expr1</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>$</span><span class=s>&#34;{expr}-{expr1}&#34;</span>  
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>Mul</span><span class=o>(</span><span class=n>expr</span><span class=o>,</span> <span class=n>expr1</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>$</span><span class=s>&#34;{expr}*{expr1}&#34;</span>  
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>Div</span><span class=o>(</span><span class=n>expr</span><span class=o>,</span> <span class=n>expr1</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>$</span><span class=s>&#34;{expr}/{expr1}&#34;</span>  
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>Paren</span> <span class=n>expr</span> <span class=o>-&gt;</span> <span class=o>$</span><span class=s>&#34;({expr})&#34;</span>  
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=n>Integer</span> <span class=n>i</span> <span class=o>-&gt;</span> <span class=o>$</span><span class=s>&#34;{i}&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>We even have a cute little ToString method so we can sanely print our expressions for debugging (Who knows?)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=nv>rec</span> <span class=n>parse_</span> <span class=o>(</span><span class=n>tokens</span><span class=o>:</span> <span class=n>Token</span> <span class=kt>list</span><span class=o>)</span> <span class=o>=</span>  
</span></span><span class=line><span class=cl>	<span class=k>let</span> <span class=nv>mutable</span> <span class=n>lhs</span><span class=o>,</span> <span class=n>lhs_xs</span> <span class=o>=</span>  
</span></span><span class=line><span class=cl>		<span class=k>match</span> <span class=n>tokens</span> <span class=k>with</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=n>None</span><span class=o>,</span> <span class=bp>[]</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=n>Integer</span> <span class=n>i</span> <span class=o>::</span> <span class=n>xs</span> <span class=o>-&gt;</span> <span class=n>Some</span><span class=o>(</span><span class=nn>Expr</span><span class=p>.</span><span class=n>Integer</span> <span class=n>i</span><span class=o>),</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=n>LParen</span> <span class=o>::</span> <span class=n>RParen</span> <span class=o>::</span> <span class=n>xs</span> <span class=o>-&gt;</span> <span class=n>None</span><span class=o>,</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=n>LParen</span> <span class=o>::</span> <span class=n>xs</span> <span class=o>-&gt;</span>  
</span></span><span class=line><span class=cl>			<span class=k>let</span> <span class=nv>expr</span><span class=o>,</span> <span class=n>xs</span> <span class=o>=</span> <span class=n>parse_</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>			<span class=k>let</span> <span class=nv>xs</span> <span class=o>=</span>  
</span></span><span class=line><span class=cl>				<span class=k>match</span> <span class=n>xs</span> <span class=k>with</span>  
</span></span><span class=line><span class=cl>				<span class=o>|</span> <span class=n>RParen</span> <span class=o>::</span> <span class=n>xs</span> <span class=o>-&gt;</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>				<span class=o>|</span> <span class=n>x</span> <span class=o>::</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>failwith</span> <span class=o>$</span><span class=s>&#34;Expected to consume ), found {x}&#34;</span>  
</span></span><span class=line><span class=cl>				<span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=n>failwith</span> <span class=s>&#34;Expected to consume ), found EOF&#34;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>			<span class=nn>Option</span><span class=p>.</span><span class=n>map</span> <span class=nn>Expr</span><span class=p>.</span><span class=n>Paren</span> <span class=n>expr</span><span class=o>,</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=n>x</span> <span class=o>::</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>failwith</span> <span class=o>$</span><span class=s>&#34;Wanted to start parsing an expression, found {x}&#34;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>	<span class=k>let</span> <span class=nv>bind</span> <span class=o>(</span><span class=n>fn</span><span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>Option</span> <span class=o>*</span> <span class=k>&#39;</span><span class=n>c</span><span class=o>)</span> <span class=o>(</span><span class=n>option</span><span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=n>option</span><span class=o>)</span> <span class=o>(</span><span class=n>xs</span><span class=o>:</span> <span class=k>&#39;</span><span class=n>c</span><span class=o>)</span> <span class=o>=</span>  
</span></span><span class=line><span class=cl>		<span class=k>match</span> <span class=n>option</span> <span class=k>with</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=n>Some</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>fn</span> <span class=n>x</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=n>None</span> <span class=o>-&gt;</span> <span class=n>None</span><span class=o>,</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>	<span class=n>bind</span>  
</span></span><span class=line><span class=cl>		<span class=o>(</span><span class=k>fun</span> <span class=n>lhs</span> <span class=o>-&gt;</span>  
</span></span><span class=line><span class=cl>			<span class=k>match</span> <span class=n>lhs_xs</span> <span class=k>with</span>  
</span></span><span class=line><span class=cl>			<span class=o>|</span> <span class=n>Add</span> <span class=o>::</span> <span class=n>xs</span> <span class=o>-&gt;</span>  
</span></span><span class=line><span class=cl>				<span class=k>let</span> <span class=nv>rhs</span><span class=o>,</span> <span class=n>xs</span> <span class=o>=</span> <span class=n>parse_</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>				<span class=o>(</span><span class=nn>Option</span><span class=p>.</span><span class=n>map</span> <span class=o>(</span><span class=k>fun</span> <span class=n>rhs</span> <span class=o>-&gt;</span> <span class=nn>Expr</span><span class=p>.</span><span class=n>Add</span><span class=o>(</span><span class=n>lhs</span><span class=o>,</span> <span class=n>rhs</span><span class=o>))</span> <span class=n>rhs</span><span class=o>),</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>			<span class=o>|</span> <span class=n>Sub</span> <span class=o>::</span> <span class=n>xs</span> <span class=o>-&gt;</span>  
</span></span><span class=line><span class=cl>				<span class=k>let</span> <span class=nv>rhs</span><span class=o>,</span> <span class=n>xs</span> <span class=o>=</span> <span class=n>parse_</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>				<span class=o>(</span><span class=nn>Option</span><span class=p>.</span><span class=n>map</span> <span class=o>(</span><span class=k>fun</span> <span class=n>rhs</span> <span class=o>-&gt;</span> <span class=nn>Expr</span><span class=p>.</span><span class=n>Sub</span><span class=o>(</span><span class=n>lhs</span><span class=o>,</span> <span class=n>rhs</span><span class=o>))</span> <span class=n>rhs</span><span class=o>),</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>			<span class=o>|</span> <span class=n>Mul</span> <span class=o>::</span> <span class=n>xs</span> <span class=o>-&gt;</span>  
</span></span><span class=line><span class=cl>				<span class=k>let</span> <span class=nv>rhs</span><span class=o>,</span> <span class=n>xs</span> <span class=o>=</span> <span class=n>parse_</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>				<span class=o>(</span><span class=nn>Option</span><span class=p>.</span><span class=n>map</span> <span class=o>(</span><span class=k>fun</span> <span class=n>rhs</span> <span class=o>-&gt;</span> <span class=nn>Expr</span><span class=p>.</span><span class=n>Mul</span><span class=o>(</span><span class=n>lhs</span><span class=o>,</span> <span class=n>rhs</span><span class=o>))</span> <span class=n>rhs</span><span class=o>),</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>			<span class=o>|</span> <span class=n>Div</span> <span class=o>::</span> <span class=n>xs</span> <span class=o>-&gt;</span>  
</span></span><span class=line><span class=cl>				<span class=k>let</span> <span class=nv>rhs</span><span class=o>,</span> <span class=n>xs</span> <span class=o>=</span> <span class=n>parse_</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>				<span class=o>(</span><span class=nn>Option</span><span class=p>.</span><span class=n>map</span> <span class=o>(</span><span class=k>fun</span> <span class=n>rhs</span> <span class=o>-&gt;</span> <span class=nn>Expr</span><span class=p>.</span><span class=n>Div</span><span class=o>(</span><span class=n>lhs</span><span class=o>,</span> <span class=n>rhs</span><span class=o>))</span> <span class=n>rhs</span><span class=o>),</span> <span class=n>xs</span>  
</span></span><span class=line><span class=cl>			<span class=o>|</span> <span class=bp>[]</span> <span class=o>-&gt;</span> <span class=n>Some</span> <span class=n>lhs</span><span class=o>,</span> <span class=bp>[]</span>  
</span></span><span class=line><span class=cl>			<span class=o>|</span> <span class=n>RParen</span> <span class=o>::</span> <span class=o>_</span> <span class=k>as</span> <span class=n>xss</span> <span class=o>-&gt;</span> <span class=n>Some</span> <span class=n>lhs</span><span class=o>,</span> <span class=n>xss</span>  
</span></span><span class=line><span class=cl>			<span class=o>|</span> <span class=n>otherwise</span> <span class=o>-&gt;</span> <span class=n>failwith</span> <span class=o>$</span><span class=s>&#34;Expected to consume either expression end or an operator, found {otherwise}&#34;</span><span class=o>)</span>  
</span></span><span class=line><span class=cl>	<span class=n>lhs</span>  
</span></span><span class=line><span class=cl>	<span class=n>lhs_xs</span>
</span></span></code></pre></td></tr></table></div></div><p>If you can understand F#, or ML, or any ML-like language, try having a go for yourself. (Definitely not making my job here easier.)</p><blockquote><p>Cat: <em>whistles</em> He always was a lazy bu~</p></blockquote><p>Pick your next words very wisely, Cat.</p><p>Fear not, our parser is separate into <em>two</em> parts.</p><a href=#the-lhs><h1 id=the-lhs><span class=hanchor arialabel=Anchor># </span>The LHS</h1></a><p>First, we match over an integer token, if it’s matched then, then we form an integer expression. Then we match over paranthesis, no fancy business here really, we just iterate over the LParen <code>(</code> and then parse an expression, ending with <em>consuming</em> an RParen <code>)</code>. Consuming being, that we <em>expect</em> a specific token to be there, and bailing if the token isn’t there.</p><p>Note how we didn’t really care about the operators…till now.</p><a href=#the-rhs><h1 id=the-rhs><span class=hanchor arialabel=Anchor># </span>The RHS</h1></a><p>Now we look if our LHS expression is followed with an operator, i.e Add/Mul/Sub/Div. Then, we parse <em>another</em> expression and we form the appropriate expression. If the operator was Add, then an addition expression, and so on.</p><a href=#what-the-f><h1 id=what-the-f><span class=hanchor arialabel=Anchor># </span>What the F#$%?</h1></a><p>If you’re coming from Pratt Parsing, this will be Really odd for you. This is very similar, yet so far. We don’t care about the precedence magic in our parser <strong>At All.</strong></p><p>But we might be forgetting something here…</p><blockquote><ul><li>add <code>((</code> at the <strong>beginning of each expression</strong> and after each left parenthesis in the original expression; and</li><li>add <code>))</code> at the <strong>end of the expression</strong> and before each right parenthesis in the original expression.</li></ul></blockquote><p>Ahaha!~ Let’s get at it. Careful readers might’ve noticed that similar to our lexer pattern before, our parser function was named <code>parse_</code>.</p><p>So, let’s a make a wrapper that implements these additions.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=nv>parse</span> <span class=n>tokens</span> <span class=o>=</span>  
</span></span><span class=line><span class=cl>	<span class=n>fst</span> <span class=o>(</span><span class=n>parse_</span> <span class=o>([</span> <span class=n>LParen</span><span class=o>;</span> <span class=n>LParen</span> <span class=o>]</span> <span class=o>@</span> <span class=n>tokens</span> <span class=o>@</span> <span class=o>[</span> <span class=n>RParen</span><span class=o>;</span> <span class=n>RParen</span> <span class=o>]))</span>
</span></span></code></pre></td></tr></table></div></div><p>There we go.</p><a href=#the-interpreter><h1 id=the-interpreter><span class=hanchor arialabel=Anchor># </span>The Interpreter</h1></a><blockquote><p>Cat: Sir, It’s 22:42</p></blockquote><p>Sleep is for the weak, Cat.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=nv>rec</span> <span class=n>interpret</span> <span class=o>(</span><span class=n>expr</span><span class=o>:</span> <span class=n>Expr</span><span class=o>)</span> <span class=o>=</span>  
</span></span><span class=line><span class=cl>	<span class=k>match</span> <span class=n>expr</span> <span class=k>with</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=nn>Expr</span><span class=p>.</span><span class=n>Add</span><span class=o>(</span><span class=n>expr</span><span class=o>,</span> <span class=n>expr1</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=n>interpret</span> <span class=n>expr</span><span class=o>)</span> <span class=o>+</span> <span class=o>(</span><span class=n>interpret</span> <span class=n>expr1</span><span class=o>)</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=nn>Expr</span><span class=p>.</span><span class=n>Sub</span><span class=o>(</span><span class=n>expr</span><span class=o>,</span> <span class=n>expr1</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=n>interpret</span> <span class=n>expr</span><span class=o>)</span> <span class=o>-</span> <span class=o>(</span><span class=n>interpret</span> <span class=n>expr1</span><span class=o>)</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=nn>Expr</span><span class=p>.</span><span class=n>Mul</span><span class=o>(</span><span class=n>expr</span><span class=o>,</span> <span class=n>expr1</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=n>interpret</span> <span class=n>expr</span><span class=o>)</span> <span class=o>*</span> <span class=o>(</span><span class=n>interpret</span> <span class=n>expr1</span><span class=o>)</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=nn>Expr</span><span class=p>.</span><span class=n>Div</span><span class=o>(</span><span class=n>expr</span><span class=o>,</span> <span class=n>expr1</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=n>interpret</span> <span class=n>expr</span><span class=o>)</span> <span class=o>/</span> <span class=o>(</span><span class=n>interpret</span> <span class=n>expr1</span><span class=o>)</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=nn>Expr</span><span class=p>.</span><span class=n>Paren</span> <span class=n>expr</span> <span class=o>-&gt;</span> <span class=n>interpret</span> <span class=n>expr</span>  
</span></span><span class=line><span class=cl>		<span class=o>|</span> <span class=nn>Expr</span><span class=p>.</span><span class=n>Integer</span> <span class=n>i</span> <span class=o>-&gt;</span> <span class=n>i</span>
</span></span></code></pre></td></tr></table></div></div><p>Look, do I <em>need</em> to explain this? <em>Something something, is left to the reader as an exercise.</em></p><a href=#the-final-result><h1 id=the-final-result><span class=hanchor arialabel=Anchor># </span>The Final Result</h1></a><p>So, Olympian/War Hero/Homeless person, did you have fun on this wild journey from the past? (Say yes, you. I still have a dozen of those combustible floats with me.)</p><p>Old algorithms are a blast, and this is no exception. It <em>works</em> and it works magically well. And, it’s pretty non-obvious on <em>why</em>. But it clicks after a hot second of “WTF?”, it simulates precedence using parenthesis depth.</p><p>Now, I’m going to hit the sack. <em>Zzz…..</em></p><blockquote><p>Cat: He’s gone, you should too! He sleep-walks with them combustible floats at hand. Be free! You don’t <em>want</em> to be in his cursed cave again!</p></blockquote><p>Cat, I’m still awake.</p><blockquote><p>Cat: Fuck.</p></blockquote><hr></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://gimbles.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made with <3 and <a href=https://github.com/jackyzha0/quartz>Quartz</a>!</p><ul><li><a href=https://gimbles.github.io/>Home</a></li><li><a href=https://github.com/gimbles>GitHub</a></li></ul></footer></div></div></body></html>