{"/":{"title":"Gimbling away","content":"\nHello \\\\o.\n\nI'm Gim. This is my website. I take notes here, plan out designs, write an article or two sometimes.\n\nI code Rust, F#, Julia. Git{Hub, Lab} at `@gimbles`. Discord at `@gimbling.away`. \n\n","lastmodified":"2023-07-07T14:57:23.196153608Z","tags":[]},"/notes/The-worlds-Best-operator-precedence-aware-parsing-algorithm":{"title":"The world's Best* operator precedence-aware parsing algorithm","content":"\nWe here at Gimbling Science take cursedness very seriously. I’m Gim! I own the place. This is my first article on this (unchanged until now) website as part of The Writing Gaggle in the Rust Community Discord Server. I’m generally pretty excited.\n\n\u003e Cat: And so am I!\n\nThat eager voice you heard is the lovely Cat, my assistant. Rest assured, she won’t interrupt you too much. Isn’t that _right_, Cat?\n\n\u003e Cat: I’ll try (meow)\n\nShe’s the backbone of this corporation. Cute as a cat (duh), too. Sorry, fellas. She’s married. To cursed!\n\n# Right, where were we?\n\nLet’s hold our meows together, folks, and get our weapons together. My weapon of choice is [F#](https://fsharp.org/).\n\nFor the sake of simplicity, this article will only focus on basic _math_. Emphasis on _basic_.\n\n\u003e Cat: Did you just~\n\nShhh.\n\n# # What’s the fuzz, Gim?\n\nNow we all know the good ol’ Pratt Parsing. Some people even prefer recursive descent. But nothing is as cursed as _The FORTRAN way._\n\nLet’s dive into [Wikipedia…](https://en.wikipedia.org/wiki/Operator-precedence_parser)\n\n\u003e Another approach is to first fully parenthesize the expression, inserting a number of parentheses around each operator, such that they lead to the correct precedence even when parsed with a linear, left-to-right parser. This algorithm was used in the early [FORTRAN I](https://web.archive.org/web/20230517120658/https://en.wikipedia.org/wiki/Fortran#FORTRAN) compiler: [[7]](https://en.wikipedia.org/wiki/Operator-precedence_parser#cite_note-Padua2000-7)\n\n\u003e The Fortran I compiler would expand each operator with a sequence of parentheses. In a simplified form of the algorithm, it would\n\u003e \n\u003e - replace `+` and `–` with `))+((` and `))-((`, respectively;\n\u003e - replace `*` and `/` with `)*(` and `)/(`, respectively;\n\u003e - add `((` at the beginning of each expression and after each left parenthesis in the original expression; and\n\u003e - add `))` at the end of the expression and before each right parenthesis in the original expression.\n\u003e \n\u003e Although not obvious, the algorithm was correct, and, in the words of [Knuth](https://web.archive.org/web/20230517120658/https://en.wikipedia.org/wiki/Donald_Knuth), “The resulting formula is properly parenthesized, believe it or not.” [[8]](https://web.archive.org/web/20230517120658/https://en.wikipedia.org/wiki/Operator-precedence_parser#cite_note-Knuth1962-8)\n\nLook, I said cursed _for a reason._ And in the words of Knuth, it _works_. So don’t touch it.\n\n\u003e Cat: I don’t think Knuth said that, Gim…\n\n# The Lexer\n\nThat means all we have is parenthesis for scoping, integers for integers, and operators for operating.\n\n```fsharp\nlet rec private lex_ (source: char ReadOnlySpan) (index: int) (collector: Token array) =  \n\tif index = source.Length then\n\t\tcollector\n\telse\n\t\tlet character = source[index]\n  \n\t\tmatch character with  \n\t\t| ' ' -\u003e lex_ source (index + 1) collector  \n\t\t| '+' -\u003e lex_ source (index + 1) (Array.append collector [| RParen; RParen; Add; LParen; LParen |])  \n\t\t| '-' -\u003e lex_ source (index + 1) (Array.append collector [| RParen; RParen; Sub; LParen; LParen |])  \n\t\t| '/' -\u003e lex_ source (index + 1) (Array.append collector [| RParen; Div; LParen |])  \n\t\t| '*' -\u003e lex_ source (index + 1) (Array.append collector [| RParen; Mul; LParen |])  \n\t\t| '(' -\u003e lex_ source (index + 1) (Array.append collector [| LParen; LParen; LParen |])  \n\t\t| ')' -\u003e lex_ source (index + 1) (Array.append collector [| RParen; RParen; RParen |])  \n\t\t| char when Char.IsDigit char -\u003e  \n\t\t\tlet index_till_int = (consumeWhile source (Char.IsDigit \u003e\u003e not) index)  \n\t\t\tlet int = double (source.Slice(index, index_till_int - index).ToString())  \n\t\t\tlex_ source index_till_int (Array.append collector [| Integer int |])  \n\t\t| char -\u003e failwith $\"Unknown token {char}\"  \n  \nlet lex (source: char ReadOnlySpan) = lex_ source 0 [||]\n```\n\nLet’s go step-by-step, understanding what’s going on here. Now I’m a _Span/ReadOnlySpan shill_. Functional programming doesn’t have to be slow! I blame the linked lists! The govermen~\n\n\u003e Cat: Sir, the lexer.\n\nRight. A brief overview of what’s going on here is this. Our main lexer is in a private function `lex_`. I’ll explain later why this needs to be a thing.\n\nWe take in a parameter, containing the original source code. Strings in .NET land are arrays of _chars._ They even have an implicit conversion operator to `ReadOnlySpan\u003cchar\u003e`. The second being the _index_ we’re currently at. And the third being a collector that we append our tokens into.\n\nWe get our current character by indexing the span with the current index, and we iterate by recursing with the index bumped up. This is _fast!_ As fast as traditional looping. Although, this is talks for later.\n\nIf the current index is same as the length of the original source, we can conclude that we have reached the end of the source and we can stop lexing further. Now it’s pretty simple, our grammar isn’t really that complex. In a real compiler, I would use a lexer generator like [Logos](https://lib.rs/logos) instead however.\n\nWe match over the character, ignoring the whitespace entirely and just bumping the index. Then matching over the different operators and…\n\n\u003e Cat: WTF?!\n\nCat, did you not read the script? Just scroll up a bit, you lazy bastard.\n\nAt the lexer stage, we transform the operators into what the algorithm defines.\n\n\u003e - replace `+` and `–` with `))+((` and `))-((`, respectively;\n\u003e - replace `*` and `/` with `)*(` and `)/(`, respectively;\n\nSame with the parenthesis.\n\n\u003e - add `((` at the beginning of each expression and after **each left parenthesis in the original expression**; and\n\u003e - add `))` at the end of the expression and before **each right parenthesis in the original expression**.\n\nTo lex integers, we increment the current index till `source[index]` is a _digit_. Then we fetch a sub-span from the original span, convert it into a string, and parse it as a **`double`**.\n\n\u003e Cat: Sir, you remember that time you threatened people to blow them up with combustible floats?\n\nCat, this is desparate times.\n\nThat’s our entire lexer! That’s all we have. Fear not, war hero, we will implement this same algorithm in the future in a _real_ language with complex expressions and not just integers. We don’t even have unops yet.\n\n# The Parser\n\nOur parser needs to parse into a some structure. Our grammar isn’t particularly complex enough to have a proper AST. However, we can represent an expression using a structure like this.\n\n```fsharp\n[\u003cRequireQualifiedAccess\u003e]  \ntype Expr =\n    | Add of Expr * Expr  \n    | Sub of Expr * Expr  \n    | Mul of Expr * Expr  \n    | Div of Expr * Expr  \n    | Paren of Expr  \n    | Integer of double  \n  \n    override self.ToString() =  \n        match self with  \n            | Add(expr, expr1) -\u003e $\"{expr}+{expr1}\"  \n            | Sub(expr, expr1) -\u003e $\"{expr}-{expr1}\"  \n            | Mul(expr, expr1) -\u003e $\"{expr}*{expr1}\"  \n            | Div(expr, expr1) -\u003e $\"{expr}/{expr1}\"  \n            | Paren expr -\u003e $\"({expr})\"  \n            | Integer i -\u003e $\"{i}\"\n```\n\nWe even have a cute little ToString method so we can sanely print our expressions for debugging (Who knows?)\n\n```fsharp\nlet rec parse_ (tokens: Token list) =  \n\tlet mutable lhs, lhs_xs =  \n\t\tmatch tokens with  \n\t\t| [] -\u003e None, []  \n\t\t| Integer i :: xs -\u003e Some(Expr.Integer i), xs  \n\t\t| LParen :: RParen :: xs -\u003e None, xs  \n\t\t| LParen :: xs -\u003e  \n\t\t\tlet expr, xs = parse_ xs  \n  \n\t\t\tlet xs =  \n\t\t\t\tmatch xs with  \n\t\t\t\t| RParen :: xs -\u003e xs  \n\t\t\t\t| x :: _ -\u003e failwith $\"Expected to consume ), found {x}\"  \n\t\t\t\t| [] -\u003e failwith \"Expected to consume ), found EOF\"  \n  \n\t\t\tOption.map Expr.Paren expr, xs  \n\t\t| x :: _ -\u003e failwith $\"Wanted to start parsing an expression, found {x}\"  \n  \n\tlet bind (fn: 'a -\u003e 'a Option * 'c) (option: 'a option) (xs: 'c) =  \n\t\tmatch option with  \n\t\t| Some x -\u003e fn x  \n\t\t| None -\u003e None, xs  \n  \n\tbind  \n\t\t(fun lhs -\u003e  \n\t\t\tmatch lhs_xs with  \n\t\t\t| Add :: xs -\u003e  \n\t\t\t\tlet rhs, xs = parse_ xs  \n\t\t\t\t(Option.map (fun rhs -\u003e Expr.Add(lhs, rhs)) rhs), xs  \n\t\t\t| Sub :: xs -\u003e  \n\t\t\t\tlet rhs, xs = parse_ xs  \n\t\t\t\t(Option.map (fun rhs -\u003e Expr.Sub(lhs, rhs)) rhs), xs  \n\t\t\t| Mul :: xs -\u003e  \n\t\t\t\tlet rhs, xs = parse_ xs  \n\t\t\t\t(Option.map (fun rhs -\u003e Expr.Mul(lhs, rhs)) rhs), xs  \n\t\t\t| Div :: xs -\u003e  \n\t\t\t\tlet rhs, xs = parse_ xs  \n\t\t\t\t(Option.map (fun rhs -\u003e Expr.Div(lhs, rhs)) rhs), xs  \n\t\t\t| [] -\u003e Some lhs, []  \n\t\t\t| RParen :: _ as xss -\u003e Some lhs, xss  \n\t\t\t| otherwise -\u003e failwith $\"Expected to consume either expression end or an operator, found {otherwise}\")  \n\tlhs  \n\tlhs_xs\n```\n\nIf you can understand F#, or ML, or any ML-like language, try having a go for yourself. (Definitely not making my job here easier.)\n\n\u003e Cat: _whistles_ He always was a lazy bu~\n\nPick your next words very wisely, Cat.\n\nFear not, our parser is separate into _two_ parts.\n\n# The LHS\n\nFirst, we match over an integer token, if it’s matched then, then we form an integer expression. Then we match over paranthesis, no fancy business here really, we just iterate over the LParen `(` and then parse an expression, ending with _consuming_ an RParen `)`. Consuming being, that we _expect_ a specific token to be there, and bailing if the token isn’t there.\n\nNote how we didn’t really care about the operators…till now.\n\n# The RHS\n\nNow we look if our LHS expression is followed with an operator, i.e Add/Mul/Sub/Div. Then, we parse _another_ expression and we form the appropriate expression. If the operator was Add, then an addition expression, and so on.\n\n# What the F#$%?\n\nIf you’re coming from Pratt Parsing, this will be Really odd for you. This is very similar, yet so far. We don’t care about the precedence magic in our parser **At All.**\n\nBut we might be forgetting something here…\n\n\u003e - add `((` at the **beginning of each expression** and after each left parenthesis in the original expression; and\n\u003e - add `))` at the **end of the expression** and before each right parenthesis in the original expression.\n\nAhaha!~ Let’s get at it. Careful readers might’ve noticed that similar to our lexer pattern before, our parser function was named `parse_`.\n\nSo, let’s a make a wrapper that implements these additions.\n\n```fsharp\nlet parse tokens =  \n\tfst (parse_ ([ LParen; LParen ] @ tokens @ [ RParen; RParen ]))\n```\n\nThere we go.\n\n# The Interpreter\n\n\u003e Cat: Sir, It’s 22:42\n\nSleep is for the weak, Cat.\n\n```fsharp\nlet rec interpret (expr: Expr) =  \n\tmatch expr with  \n\t\t| Expr.Add(expr, expr1) -\u003e (interpret expr) + (interpret expr1)  \n\t\t| Expr.Sub(expr, expr1) -\u003e (interpret expr) - (interpret expr1)  \n\t\t| Expr.Mul(expr, expr1) -\u003e (interpret expr) * (interpret expr1)  \n\t\t| Expr.Div(expr, expr1) -\u003e (interpret expr) / (interpret expr1)  \n\t\t| Expr.Paren expr -\u003e interpret expr  \n\t\t| Expr.Integer i -\u003e i\n```\n\nLook, do I _need_ to explain this? _Something something, is left to the reader as an exercise._\n\n# The Final Result\n\nSo, Olympian/War Hero/Homeless person, did you have fun on this wild journey from the past? (Say yes, you. I still have a dozen of those combustible floats with me.)\n\nOld algorithms are a blast, and this is no exception. It _works_ and it works magically well. And, it’s pretty non-obvious on _why_. But it clicks after a hot second of “WTF?”, it simulates precedence using parenthesis depth.\n\nNow, I’m going to hit the sack. _Zzz….._\n\n\u003e Cat: He’s gone, you should too! He sleep-walks with them combustible floats at hand. Be free! You don’t _want_ to be in his cursed cave again!\n\nCat, I’m still awake.\n\n\u003e Cat: Fuck.\n\n---","lastmodified":"2023-07-07T14:57:23.196153608Z","tags":[]}}