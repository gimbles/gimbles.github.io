{"/":{"title":"Gimbling away","content":"\nHello \\\\o.\n\nI'm Gim. This is my website. I take notes here, plan out designs, write an article or two sometimes.\n\nI code Rust, F#, Julia. Git{Hub, Lab} at `@gimbles`. Discord at `@gimbling.away`. \n\n","lastmodified":"2023-11-16T09:31:16.586594332Z","tags":[]},"/notes/Chai-Recipe":{"title":"Chai Recipe","content":"A recipe from your local Gim instance. \n\n# Ingredients\n- Milk\n- Tea\n- Water\n- Sugar (Optional)\n- Ginger (Optional)\n- Cardamom/Elaichi (Optional)\n\nAll three of them are optional but recommended to have.\n\n# Method\n\nThis is for making chai for two people\n- Put the pan on the stove (Turn it on)\n- Put two cups water into the pan\n- Put three small-spoons of tea into the pan\n- Wait for 15-30 seconds, until you see a black-ish colour\n- Now put one cup of milk\n- Wait for a 10-20 seconds, it should become slightly orange-ish\n- (OPTIONAL) In the meanwhile, take your mortar and pestle and put your cardamom and ginger into it. Smash away and chuck it into the pan.\n- Boil it two-three times. Three if it's a lot of chai. But since it's only two cups, two times should be fine.\n- Strain it into cups \\:)\n\nIf you want it to be sweet, put some sugar into it and swirl it around. If you can feel sugar stuck onto the bottom you haven't swirled it enough :v\n\nEnjoy üòÑ\n","lastmodified":"2023-11-16T09:31:16.586594332Z","tags":[]},"/notes/The-worlds-Best-operator-precedence-aware-parsing-algorithm":{"title":"The world's Best* operator precedence-aware parsing algorithm","content":"\nWe here at Gimbling Science take cursedness very seriously. I‚Äôm Gim! I own the place. This is my first article on this (unchanged until now) website as part of The Writing Gaggle in the Rust Community Discord Server. I‚Äôm generally pretty excited.\n\n\u003e Cat: And so am I!\n\nThat eager voice you heard is the lovely Cat, my assistant. Rest assured, she won‚Äôt interrupt you too much. Isn‚Äôt that _right_, Cat?\n\n\u003e Cat: I‚Äôll try (meow)\n\nShe‚Äôs the backbone of this corporation. Cute as a cat (duh), too. Sorry, fellas. She‚Äôs married. To cursed!\n\n# Right, where were we?\n\nLet‚Äôs hold our meows together, folks, and get our weapons together. My weapon of choice is [F#](https://fsharp.org/).\n\nFor the sake of simplicity, this article will only focus on basic _math_. Emphasis on _basic_.\n\n\u003e Cat: Did you just~\n\nShhh.\n\n# What‚Äôs the fuzz, Gim?\n\nNow we all know the good ol‚Äô Pratt Parsing. Some people even prefer recursive descent. But nothing is as cursed as _The FORTRAN way._\n\nLet‚Äôs dive into [Wikipedia‚Ä¶](https://en.wikipedia.org/wiki/Operator-precedence_parser)\n\n\u003e Another approach is to first fully parenthesize the expression, inserting a number of parentheses around each operator, such that they lead to the correct precedence even when parsed with a linear, left-to-right parser. This algorithm was used in the early [FORTRAN I](https://web.archive.org/web/20230517120658/https://en.wikipedia.org/wiki/Fortran#FORTRAN) compiler: [[7]](https://en.wikipedia.org/wiki/Operator-precedence_parser#cite_note-Padua2000-7)\n\n\u003e The Fortran I compiler would expand each operator with a sequence of parentheses. In a simplified form of the algorithm, it would\n\u003e \n\u003e - replace `+` and `‚Äì` with `))+((` and `))-((`, respectively;\n\u003e - replace `*` and `/` with `)*(` and `)/(`, respectively;\n\u003e - add `((` at the beginning of each expression and after each left parenthesis in the original expression; and\n\u003e - add `))` at the end of the expression and before each right parenthesis in the original expression.\n\u003e \n\u003e Although not obvious, the algorithm was correct, and, in the words of [Knuth](https://web.archive.org/web/20230517120658/https://en.wikipedia.org/wiki/Donald_Knuth), ‚ÄúThe resulting formula is properly parenthesized, believe it or not.‚Äù [[8]](https://web.archive.org/web/20230517120658/https://en.wikipedia.org/wiki/Operator-precedence_parser#cite_note-Knuth1962-8)\n\nLook, I said cursed _for a reason._ And in the words of Knuth, it _works_. So don‚Äôt touch it.\n\n\u003e Cat: I don‚Äôt think Knuth said that, Gim‚Ä¶\n\n# The Lexer\n\nThat means all we have is parenthesis for scoping, integers for integers, and operators for operating.\n\n```fsharp\nlet rec private lex_ (source: char ReadOnlySpan) (index: int) (collector: Token array) =  \n\tif index = source.Length then\n\t\tcollector\n\telse\n\t\tlet character = source[index]\n  \n\t\tmatch character with  \n\t\t| ' ' -\u003e lex_ source (index + 1) collector  \n\t\t| '+' -\u003e lex_ source (index + 1) (Array.append collector [| RParen; RParen; Add; LParen; LParen |])  \n\t\t| '-' -\u003e lex_ source (index + 1) (Array.append collector [| RParen; RParen; Sub; LParen; LParen |])  \n\t\t| '/' -\u003e lex_ source (index + 1) (Array.append collector [| RParen; Div; LParen |])  \n\t\t| '*' -\u003e lex_ source (index + 1) (Array.append collector [| RParen; Mul; LParen |])  \n\t\t| '(' -\u003e lex_ source (index + 1) (Array.append collector [| LParen; LParen; LParen |])  \n\t\t| ')' -\u003e lex_ source (index + 1) (Array.append collector [| RParen; RParen; RParen |])  \n\t\t| char when Char.IsDigit char -\u003e  \n\t\t\tlet index_till_int = (consumeWhile source (Char.IsDigit \u003e\u003e not) index)  \n\t\t\tlet int = double (source.Slice(index, index_till_int - index).ToString())  \n\t\t\tlex_ source index_till_int (Array.append collector [| Integer int |])  \n\t\t| char -\u003e failwith $\"Unknown token {char}\"  \n  \nlet lex (source: char ReadOnlySpan) = lex_ source 0 [||]\n```\n\nLet‚Äôs go step-by-step, understanding what‚Äôs going on here. Now I‚Äôm a _Span/ReadOnlySpan shill_. Functional programming doesn‚Äôt have to be slow! I blame the linked lists! The govermen~\n\n\u003e Cat: Sir, the lexer.\n\nRight. A brief overview of what‚Äôs going on here is this. Our main lexer is in a private function `lex_`. I‚Äôll explain later why this needs to be a thing.\n\nWe take in a parameter, containing the original source code. Strings in .NET land are arrays of _chars._ They even have an implicit conversion operator to `ReadOnlySpan\u003cchar\u003e`. The second being the _index_ we‚Äôre currently at. And the third being a collector that we append our tokens into.\n\nWe get our current character by indexing the span with the current index, and we iterate by recursing with the index bumped up. This is _fast!_ As fast as traditional looping. Although, this is talks for later.\n\nIf the current index is same as the length of the original source, we can conclude that we have reached the end of the source and we can stop lexing further. Now it‚Äôs pretty simple, our grammar isn‚Äôt really that complex. In a real compiler, I would use a lexer generator like [Logos](https://lib.rs/logos) instead however.\n\nWe match over the character, ignoring the whitespace entirely and just bumping the index. Then matching over the different operators and‚Ä¶\n\n\u003e Cat: WTF?!\n\nCat, did you not read the script? Just scroll up a bit, you lazy bastard.\n\nAt the lexer stage, we transform the operators into what the algorithm defines.\n\n\u003e - replace `+` and `‚Äì` with `))+((` and `))-((`, respectively;\n\u003e - replace `*` and `/` with `)*(` and `)/(`, respectively;\n\nSame with the parenthesis.\n\n\u003e - add `((` at the beginning of each expression and after **each left parenthesis in the original expression**; and\n\u003e - add `))` at the end of the expression and before **each right parenthesis in the original expression**.\n\nTo lex integers, we increment the current index till `source[index]` is a _digit_. Then we fetch a sub-span from the original span, convert it into a string, and parse it as a **`double`**.\n\n\u003e Cat: Sir, you remember that time you threatened people to blow them up with combustible floats?\n\nCat, this is desparate times.\n\nThat‚Äôs our entire lexer! That‚Äôs all we have. Fear not, war hero, we will implement this same algorithm in the future in a _real_ language with complex expressions and not just integers. We don‚Äôt even have unops yet.\n\n# The Parser\n\nOur parser needs to parse into a some structure. Our grammar isn‚Äôt particularly complex enough to have a proper AST. However, we can represent an expression using a structure like this.\n\n```fsharp\n[\u003cRequireQualifiedAccess\u003e]  \ntype Expr =\n    | Add of Expr * Expr  \n    | Sub of Expr * Expr  \n    | Mul of Expr * Expr  \n    | Div of Expr * Expr  \n    | Paren of Expr  \n    | Integer of double  \n  \n    override self.ToString() =  \n        match self with  \n            | Add(expr, expr1) -\u003e $\"{expr}+{expr1}\"  \n            | Sub(expr, expr1) -\u003e $\"{expr}-{expr1}\"  \n            | Mul(expr, expr1) -\u003e $\"{expr}*{expr1}\"  \n            | Div(expr, expr1) -\u003e $\"{expr}/{expr1}\"  \n            | Paren expr -\u003e $\"({expr})\"  \n            | Integer i -\u003e $\"{i}\"\n```\n\nWe even have a cute little ToString method so we can sanely print our expressions for debugging (Who knows?)\n\n```fsharp\nlet rec parse_ (tokens: Token list) =  \n\tlet mutable lhs, lhs_xs =  \n\t\tmatch tokens with  \n\t\t| [] -\u003e None, []  \n\t\t| Integer i :: xs -\u003e Some(Expr.Integer i), xs  \n\t\t| LParen :: RParen :: xs -\u003e None, xs  \n\t\t| LParen :: xs -\u003e  \n\t\t\tlet expr, xs = parse_ xs  \n  \n\t\t\tlet xs =  \n\t\t\t\tmatch xs with  \n\t\t\t\t| RParen :: xs -\u003e xs  \n\t\t\t\t| x :: _ -\u003e failwith $\"Expected to consume ), found {x}\"  \n\t\t\t\t| [] -\u003e failwith \"Expected to consume ), found EOF\"  \n  \n\t\t\tOption.map Expr.Paren expr, xs  \n\t\t| x :: _ -\u003e failwith $\"Wanted to start parsing an expression, found {x}\"  \n  \n\tlet bind (fn: 'a -\u003e 'a Option * 'c) (option: 'a option) (xs: 'c) =  \n\t\tmatch option with  \n\t\t| Some x -\u003e fn x  \n\t\t| None -\u003e None, xs  \n  \n\tbind  \n\t\t(fun lhs -\u003e  \n\t\t\tmatch lhs_xs with  \n\t\t\t| Add :: xs -\u003e  \n\t\t\t\tlet rhs, xs = parse_ xs  \n\t\t\t\t(Option.map (fun rhs -\u003e Expr.Add(lhs, rhs)) rhs), xs  \n\t\t\t| Sub :: xs -\u003e  \n\t\t\t\tlet rhs, xs = parse_ xs  \n\t\t\t\t(Option.map (fun rhs -\u003e Expr.Sub(lhs, rhs)) rhs), xs  \n\t\t\t| Mul :: xs -\u003e  \n\t\t\t\tlet rhs, xs = parse_ xs  \n\t\t\t\t(Option.map (fun rhs -\u003e Expr.Mul(lhs, rhs)) rhs), xs  \n\t\t\t| Div :: xs -\u003e  \n\t\t\t\tlet rhs, xs = parse_ xs  \n\t\t\t\t(Option.map (fun rhs -\u003e Expr.Div(lhs, rhs)) rhs), xs  \n\t\t\t| [] -\u003e Some lhs, []  \n\t\t\t| RParen :: _ as xss -\u003e Some lhs, xss  \n\t\t\t| otherwise -\u003e failwith $\"Expected to consume either expression end or an operator, found {otherwise}\")  \n\tlhs  \n\tlhs_xs\n```\n\nIf you can understand F#, or ML, or any ML-like language, try having a go for yourself. (Definitely not making my job here easier.)\n\n\u003e Cat: _whistles_ He always was a lazy bu~\n\nPick your next words very wisely, Cat.\n\nFear not, our parser is separate into _two_ parts.\n\n# The LHS\n\nFirst, we match over an integer token, if it‚Äôs matched then, then we form an integer expression. Then we match over paranthesis, no fancy business here really, we just iterate over the LParen `(` and then parse an expression, ending with _consuming_ an RParen `)`. Consuming being, that we _expect_ a specific token to be there, and bailing if the token isn‚Äôt there.\n\nNote how we didn‚Äôt really care about the operators‚Ä¶till now.\n\n# The RHS\n\nNow we look if our LHS expression is followed with an operator, i.e Add/Mul/Sub/Div. Then, we parse _another_ expression and we form the appropriate expression. If the operator was Add, then an addition expression, and so on.\n\n# What the F#$%?\n\nIf you‚Äôre coming from Pratt Parsing, this will be Really odd for you. This is very similar, yet so far. We don‚Äôt care about the precedence magic in our parser **At All.**\n\nBut we might be forgetting something here‚Ä¶\n\n\u003e - add `((` at the **beginning of each expression** and after each left parenthesis in the original expression; and\n\u003e - add `))` at the **end of the expression** and before each right parenthesis in the original expression.\n\nAhaha!~ Let‚Äôs get at it. Careful readers might‚Äôve noticed that similar to our lexer pattern before, our parser function was named `parse_`.\n\nSo, let‚Äôs a make a wrapper that implements these additions.\n\n```fsharp\nlet parse tokens =  \n\tfst (parse_ ([ LParen; LParen ] @ tokens @ [ RParen; RParen ]))\n```\n\nThere we go.\n\n# The Interpreter\n\n\u003e Cat: Sir, It‚Äôs 22:42\n\nSleep is for the weak, Cat.\n\n```fsharp\nlet rec interpret (expr: Expr) =  \n\tmatch expr with  \n\t\t| Expr.Add(expr, expr1) -\u003e (interpret expr) + (interpret expr1)  \n\t\t| Expr.Sub(expr, expr1) -\u003e (interpret expr) - (interpret expr1)  \n\t\t| Expr.Mul(expr, expr1) -\u003e (interpret expr) * (interpret expr1)  \n\t\t| Expr.Div(expr, expr1) -\u003e (interpret expr) / (interpret expr1)  \n\t\t| Expr.Paren expr -\u003e interpret expr  \n\t\t| Expr.Integer i -\u003e i\n```\n\nLook, do I _need_ to explain this? _Something something, is left to the reader as an exercise._\n\n# The Final Result\n\nSo, Olympian/War Hero/Homeless person, did you have fun on this wild journey from the past? (Say yes, you. I still have a dozen of those combustible floats with me.)\n\nOld algorithms are a blast, and this is no exception. It _works_ and it works magically well. And, it‚Äôs pretty non-obvious on _why_. But it clicks after a hot second of ‚ÄúWTF?‚Äù, it simulates precedence using parenthesis depth.\n\nNow, I‚Äôm going to hit the sack. _Zzz‚Ä¶.._\n\n\u003e Cat: He‚Äôs gone, you should too! He sleep-walks with them combustible floats at hand. Be free! You don‚Äôt _want_ to be in his cursed cave again!\n\nCat, I‚Äôm still awake.\n\n\u003e Cat: Fuck.\n\n---","lastmodified":"2023-11-16T09:31:16.586594332Z","tags":[]}}